# -*- coding: utf-8 -*-
"""
UCCI Protocol Implementation
Giao th·ª©c UCCI (Universal Chinese Chess Interface) cho c·ªù t∆∞·ªõng
"""

import subprocess
import threading
import queue
import time
import traceback
from typing import Optional, List, Callable


class UCCIEngine:
    """Class ƒë·ªÉ giao ti·∫øp v·ªõi engine c·ªù t∆∞·ªõng qua giao th·ª©c UCCI"""

    def __init__(self, engine_path: str, protocol: str = "auto"):
        """
        Kh·ªüi t·∫°o engine

        Args:
            engine_path: ƒê∆∞·ªùng d·∫´n ƒë·∫øn file executable c·ªßa engine
            protocol: "auto" ƒë·ªÉ auto-detect, "ucci" cho c·ªù t∆∞·ªõng, "uci" cho c·ªù vua
        """
        self.engine_path = engine_path
        self.protocol = protocol.lower()
        self.detected_protocol = None  # Protocol ƒë∆∞·ª£c detect
        self.process = None
        self.input_queue = queue.Queue()
        self.output_queue = queue.Queue()
        self.is_running = False
        self.engine_thread = None
        self.protocol_detected = False  # Flag ƒë·ªÉ bi·∫øt ƒë√£ detect xong protocol

        # Callback functions
        self.on_bestmove: Optional[Callable[[str], None]] = None
        self.on_info: Optional[Callable[[str], None]] = None

    def start(self) -> bool:
        """
        Kh·ªüi ƒë·ªông engine

        Returns:
            True n·∫øu kh·ªüi ƒë·ªông th√†nh c√¥ng, False n·∫øu th·∫•t b·∫°i
        """
        try:
            self.process = subprocess.Popen(
                self.engine_path,
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                universal_newlines=True,
                bufsize=0
            )

            self.is_running = True
            self.engine_thread = threading.Thread(
                target=self._engine_communication)
            self.engine_thread.daemon = True
            self.engine_thread.start()

            # Auto-detect protocol ho·∫∑c s·ª≠ d·ª•ng protocol ƒë√£ ch·ªâ ƒë·ªãnh
            if self.protocol == "auto":
                self._detect_protocol()
            else:
                # S·ª≠ d·ª•ng protocol ƒë√£ ch·ªâ ƒë·ªãnh
                self.detected_protocol = self.protocol
                self.protocol_detected = True
                self._send_init_command()

            return True

        except Exception as e:
            print(f"L·ªói kh·ªüi ƒë·ªông engine: {e}")
            return False

    def stop(self):
        """D·ª´ng engine"""
        if self.is_running:
            self.send_command("quit")
            self.is_running = False

            if self.process:
                self.process.terminate()
                self.process.wait(timeout=5)
                self.process = None

    def send_command(self, command: str):
        """
        G·ª≠i l·ªánh ƒë·∫øn engine

        Args:
            command: L·ªánh UCCI c·∫ßn g·ª≠i
        """
        if self.process and self.is_running:
            try:
                self.process.stdin.write(command + "\n")
                self.process.stdin.flush()
                print(f"G·ª≠i: {command}")
            except Exception as e:
                print(f"L·ªói g·ª≠i l·ªánh: {e}")

    def new_game(self):
        """B·∫Øt ƒë·∫ßu v√°n c·ªù m·ªõi"""
        protocol = self.detected_protocol or self.protocol
        if protocol == "ucci":
            self.send_command("uccinewgame")
        else:  # UCI
            self.send_command("ucinewgame")

    def set_position(self, fen: str, moves: List[str] = None):
        """
        Thi·∫øt l·∫≠p v·ªã tr√≠ b√†n c·ªù

        Args:
            fen: Chu·ªói FEN m√¥ t·∫£ v·ªã tr√≠
            moves: Danh s√°ch n∆∞·ªõc ƒëi t·ª´ v·ªã tr√≠ FEN
        """
        command = f"position fen {fen}"
        if moves:
            command += " moves " + " ".join(moves)
        self.send_command(command)

    def go(self, depth: int = None, time_ms: int = None):
        """
        Y√™u c·∫ßu engine t√¨m n∆∞·ªõc ƒëi t·ªët nh·∫•t

        Args:
            depth: ƒê·ªô s√¢u t√¨m ki·∫øm
            time_ms: Th·ªùi gian suy nghƒ© (milliseconds)
        """
        command = "go"
        if depth:
            command += f" depth {depth}"
        if time_ms:
            command += f" movetime {time_ms}"

        self.send_command(command)

    def go_infinite(self):
        """
        Y√™u c·∫ßu engine ph√¢n t√≠ch li√™n t·ª•c (infinite analysis)
        """
        self.send_command("go infinite")

    def stop_search(self):
        """D·ª´ng t√¨m ki·∫øm"""
        self.send_command("stop")

    def make_move(self, move: str):
        """
        Th√¥ng b√°o cho engine v·ªÅ n∆∞·ªõc ƒëi v·ª´a th·ª±c hi·ªán

        Args:
            move: N∆∞·ªõc ƒëi d·∫°ng UCCI (e.g., "h2e2")
        """
        # Engine s·∫Ω nh·∫≠n th√¥ng tin n√†y qua set_position v·ªõi moves history
        pass

    def get_hint(self, depth: int = 8):
        """
        Y√™u c·∫ßu engine g·ª£i √Ω n∆∞·ªõc ƒëi

        Args:
            depth: ƒê·ªô s√¢u t√¨m ki·∫øm ƒë·ªÉ g·ª£i √Ω
        """
        self.go(depth=depth)

    def _detect_protocol(self):
        """Auto-detect protocol c·ªßa engine"""
        print(f"üîç ƒêang detect protocol cho engine: {self.engine_path}")

        # Th·ª≠ UCCI tr∆∞·ªõc (v√¨ ƒë√¢y l√† app c·ªù t∆∞·ªõng)
        import time
        time.sleep(0.1)  # ƒê·ª£i engine kh·ªüi ƒë·ªông

        print("üß™ Th·ª≠ UCCI protocol...")
        self.send_command("ucci")

        # ƒê·ª£i ph·∫£n h·ªìi trong 2 gi√¢y
        import threading
        timer = threading.Timer(2.0, self._try_uci_protocol)
        timer.start()

    def _try_uci_protocol(self):
        """Th·ª≠ UCI protocol n·∫øu UCCI kh√¥ng ph·∫£n h·ªìi"""
        if not self.protocol_detected:
            print("üß™ UCCI kh√¥ng ph·∫£n h·ªìi, th·ª≠ UCI protocol...")
            self.send_command("uci")

            # Timeout cu·ªëi c√πng
            import threading
            timer = threading.Timer(2.0, self._protocol_detection_failed)
            timer.start()

    def _protocol_detection_failed(self):
        """X·ª≠ l√Ω khi kh√¥ng detect ƒë∆∞·ª£c protocol"""
        if not self.protocol_detected:
            print("‚ùå Kh√¥ng th·ªÉ detect protocol, m·∫∑c ƒë·ªãnh d√πng UCCI")
            self.detected_protocol = "ucci"
            self.protocol_detected = True

    def _send_init_command(self):
        """G·ª≠i l·ªánh kh·ªüi t·∫°o theo protocol ƒë√£ detect"""
        if self.detected_protocol == "ucci":
            self.send_command("ucci")
            print("‚úÖ S·ª≠ d·ª•ng UCCI protocol")
        else:  # UCI
            self.send_command("uci")
            print("‚úÖ S·ª≠ d·ª•ng UCI protocol")

    def get_detected_protocol(self) -> str:
        """L·∫•y protocol ƒë√£ ƒë∆∞·ª£c detect"""
        return self.detected_protocol or "unknown"

    def _engine_communication(self):
        """Thread x·ª≠ l√Ω giao ti·∫øp v·ªõi engine"""
        while self.is_running and self.process:
            try:
                if self.process.poll() is not None:
                    # Engine ƒë√£ tho√°t
                    print("Engine process ƒë√£ k·∫øt th√∫c")
                    break

                line = self.process.stdout.readline()
                if not line:
                    continue

                line = line.strip()
                if line:
                    print(f"Nh·∫≠n: {line}")
                    self._process_engine_output(line)

            except Exception as e:
                print(f"L·ªói giao ti·∫øp engine: {e}")
                print(f"Traceback: {traceback.format_exc()}")
                break

        print("Engine communication thread k·∫øt th√∫c")
        self.is_running = False

    def _process_engine_output(self, line: str):
        """
        X·ª≠ l√Ω output t·ª´ engine

        Args:
            line: D√≤ng output t·ª´ engine
        """
        parts = line.split()
        if not parts:
            return

        command = parts[0]

        if command == "ucciok":
            print("‚úÖ Engine h·ªó tr·ª£ UCCI protocol")
            if not self.protocol_detected:
                self.detected_protocol = "ucci"
                self.protocol_detected = True

        elif command == "uciok":
            print("‚úÖ Engine h·ªó tr·ª£ UCI protocol")
            if not self.protocol_detected:
                self.detected_protocol = "uci"
                self.protocol_detected = True

        elif command == "readyok":
            print("Engine ƒë√£ ready")

        elif command == "bestmove":
            if len(parts) >= 2:
                # G·ª≠i to√†n b·ªô d√≤ng bestmove ƒë·ªÉ parse c·∫£ bestmove v√† ponder
                if self.on_bestmove:
                    try:
                        # G·ª≠i to√†n b·ªô d√≤ng thay v√¨ ch·ªâ move
                        self.on_bestmove(line)
                    except Exception as e:
                        print(f"L·ªói trong callback on_bestmove: {e}")
                        print(f"Traceback: {traceback.format_exc()}")

        elif command == "info":
            if self.on_info:
                try:
                    self.on_info(line)
                except Exception as e:
                    print(f"L·ªói trong callback on_info: {e}")
                    print(f"Traceback: {traceback.format_exc()}")

        elif command == "id":
            print(f"Engine info: {' '.join(parts[1:])}")


class UCCIEngineManager:
    """Manager ƒë·ªÉ qu·∫£n l√Ω nhi·ªÅu engine"""

    def __init__(self):
        self.engines = {}
        self.current_engine = None
        self.protocol = "auto"  # T·ª± ƒë·ªông detect protocol

    def set_protocol(self, protocol: str):
        """
        ƒê·∫∑t protocol s·ª≠ d·ª•ng (deprecated - s·ª≠ d·ª•ng auto-detection)

        Args:
            protocol: "ucci", "uci", ho·∫∑c "auto" (khuy·∫øn ngh·ªã)
        """
        self.protocol = protocol.lower()
        if protocol == "auto":
            print("‚úÖ S·ª≠ d·ª•ng auto-detection protocol cho engines")
        else:
            print(
                f"‚ö†Ô∏è Manual protocol ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t th√†nh: {self.protocol.upper()}")
            print("üí° Khuy·∫øn ngh·ªã s·ª≠ d·ª•ng 'auto' ƒë·ªÉ t·ª± ƒë·ªông detect protocol")

    def get_protocol(self) -> str:
        """L·∫•y protocol hi·ªán t·∫°i"""
        return self.protocol

    def add_engine(self, name: str, path: str) -> bool:
        """
        Th√™m engine m·ªõi

        Args:
            name: T√™n engine
            path: ƒê∆∞·ªùng d·∫´n ƒë·∫øn engine

        Returns:
            True n·∫øu th√†nh c√¥ng
        """
        engine = UCCIEngine(path, self.protocol)
        if engine.start():
            self.engines[name] = engine
            return True
        return False

    def set_current_engine(self, name: str) -> bool:
        """
        Ch·ªçn engine hi·ªán t·∫°i

        Args:
            name: T√™n engine

        Returns:
            True n·∫øu th√†nh c√¥ng
        """
        if name in self.engines:
            self.current_engine = self.engines[name]
            return True
        return False

    def get_current_engine(self) -> Optional[UCCIEngine]:
        """L·∫•y engine hi·ªán t·∫°i"""
        return self.current_engine

    def stop_all_engines(self):
        """D·ª´ng t·∫•t c·∫£ engine"""
        for engine in self.engines.values():
            engine.stop()
        self.engines.clear()
        self.current_engine = None


class MultiEngineManager:
    """Manager ƒë·ªÉ qu·∫£n l√Ω v√† ch·∫°y nhi·ªÅu engine c√πng l√∫c"""

    def __init__(self):
        self.active_engines = {}  # {name: UCCIEngine}
        self.engine_results = {}  # {name: {'bestmove': str, 'evaluation': float, 'depth': int}}
        self.protocol = "auto"  # T·ª± ƒë·ªông detect protocol
        self.position_fen = None
        self.position_moves = []

        # Callbacks cho t·ª´ng engine
        self.on_engine_result = None  # Callback khi c√≥ k·∫øt qu·∫£ t·ª´ engine

    def set_protocol(self, protocol: str):
        """ƒê·∫∑t protocol cho t·∫•t c·∫£ engine (deprecated - s·ª≠ d·ª•ng auto-detection)"""
        self.protocol = protocol.lower()
        if protocol == "auto":
            print("‚úÖ MultiEngine s·ª≠ d·ª•ng auto-detection protocol")
        else:
            print(f"‚ö†Ô∏è MultiEngine manual protocol: {self.protocol.upper()}")
            print("üí° Khuy·∫øn ngh·ªã s·ª≠ d·ª•ng 'auto' ƒë·ªÉ t·ª± ƒë·ªông detect protocol")

    def add_engine(self, name: str, path: str, auto_start: bool = True) -> bool:
        """
        Th√™m engine v√†o danh s√°ch active

        Args:
            name: T√™n engine
            path: ƒê∆∞·ªùng d·∫´n engine
            auto_start: T·ª± ƒë·ªông start engine

        Returns:
            bool: True n·∫øu th√†nh c√¥ng
        """
        try:
            # S·ª≠ d·ª•ng auto-detect protocol
            engine = UCCIEngine(path, "auto")

            # Setup callbacks cho engine n√†y
            engine.on_bestmove = lambda line, engine_name=name: self._handle_engine_bestmove(
                engine_name, line)
            engine.on_info = lambda line, engine_name=name: self._handle_engine_info(
                engine_name, line)

            if auto_start and engine.start():
                self.active_engines[name] = engine
                self.engine_results[name] = {
                    'bestmove': None,
                    'evaluation': 0.0,
                    'depth': 0,
                    'nodes': 0,
                    'pv': [],
                    'protocol': 'detecting...'  # Th√™m th√¥ng tin protocol
                }

                # ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ protocol ƒë∆∞·ª£c detect
                import threading

                def update_protocol():
                    import time
                    time.sleep(3)  # ƒê·ª£i 3 gi√¢y
                    if name in self.engine_results:
                        detected = engine.get_detected_protocol()
                        self.engine_results[name]['protocol'] = detected
                        print(f"‚úì Engine {name} detected protocol: {detected}")

                threading.Thread(target=update_protocol, daemon=True).start()
                print(f"‚úì ƒê√£ th√™m engine: {name} (auto-detecting protocol...)")
                return True
            else:
                print(f"‚ùå Kh√¥ng th·ªÉ start engine: {name}")
                return False

        except Exception as e:
            print(f"‚ùå L·ªói th√™m engine {name}: {e}")
            return False

    def remove_engine(self, name: str):
        """X√≥a engine kh·ªèi danh s√°ch active"""
        if name in self.active_engines:
            self.active_engines[name].stop()
            del self.active_engines[name]
            if name in self.engine_results:
                del self.engine_results[name]
            print(f"‚úì ƒê√£ x√≥a engine: {name}")

    def get_active_engines(self) -> list:
        """L·∫•y danh s√°ch t√™n engine ƒëang active"""
        return list(self.active_engines.keys())

    def set_position_all(self, fen: str, moves: List[str] = None):
        """ƒê·∫∑t position cho t·∫•t c·∫£ engine"""
        self.position_fen = fen
        self.position_moves = moves or []

        for name, engine in self.active_engines.items():
            try:
                engine.set_position(fen, moves)
                print(f"‚úì ƒê√£ set position cho {name}")
            except Exception as e:
                print(f"‚ùå L·ªói set position cho {name}: {e}")

    def start_analysis_all(self):
        """B·∫Øt ƒë·∫ßu analysis cho t·∫•t c·∫£ engine"""
        for name, engine in self.active_engines.items():
            try:
                engine.go_infinite()
                print(f"üîç B·∫Øt ƒë·∫ßu analysis: {name}")
            except Exception as e:
                print(f"‚ùå L·ªói start analysis {name}: {e}")

    def stop_analysis_all(self):
        """D·ª´ng analysis cho t·∫•t c·∫£ engine"""
        for name, engine in self.active_engines.items():
            try:
                engine.stop_search()
                print(f"‚èπÔ∏è D·ª´ng analysis: {name}")
            except Exception as e:
                print(f"‚ùå L·ªói stop analysis {name}: {e}")

    def get_hint_all(self, depth: int = 8):
        """Y√™u c·∫ßu hint t·ª´ t·∫•t c·∫£ engine"""
        for name, engine in self.active_engines.items():
            try:
                engine.get_hint(depth)
                print(f"ü§ñ Y√™u c·∫ßu hint t·ª´ {name}")
            except Exception as e:
                print(f"‚ùå L·ªói get hint {name}: {e}")

    def get_results(self) -> dict:
        """L·∫•y k·∫øt qu·∫£ t·ª´ t·∫•t c·∫£ engine"""
        return self.engine_results.copy()

    def stop_all(self):
        """D·ª´ng t·∫•t c·∫£ engine"""
        for name in list(self.active_engines.keys()):
            self.remove_engine(name)

    def _handle_engine_bestmove(self, engine_name: str, bestmove_line: str):
        """X·ª≠ l√Ω bestmove t·ª´ engine"""
        try:
            parts = bestmove_line.split()
            if len(parts) >= 2:
                bestmove = parts[1]
                self.engine_results[engine_name]['bestmove'] = bestmove

                # Parse ponder move n·∫øu c√≥
                if len(parts) >= 4 and parts[2] == "ponder":
                    ponder = parts[3]
                    self.engine_results[engine_name]['ponder'] = ponder

                print(f"üéØ {engine_name} bestmove: {bestmove}")

                # Callback cho UI
                if self.on_engine_result:
                    self.on_engine_result(
                        engine_name, 'bestmove', self.engine_results[engine_name])

        except Exception as e:
            print(f"‚ùå L·ªói parse bestmove t·ª´ {engine_name}: {e}")

    def _handle_engine_info(self, engine_name: str, info_line: str):
        """X·ª≠ l√Ω info t·ª´ engine"""
        try:
            parts = info_line.split()

            # Parse c√°c th√¥ng tin t·ª´ info line
            i = 1  # B·ªè qua "info"
            while i < len(parts):
                if parts[i] == "depth" and i + 1 < len(parts):
                    self.engine_results[engine_name]['depth'] = int(
                        parts[i + 1])
                    i += 2
                elif parts[i] == "score" and i + 2 < len(parts):
                    if parts[i + 1] == "cp":
                        # Centipawn score
                        score = int(parts[i + 2]) / 100.0
                        self.engine_results[engine_name]['evaluation'] = score
                        i += 3
                    elif parts[i + 1] == "mate":
                        # Mate score
                        mate_moves = int(parts[i + 2])
                        self.engine_results[engine_name]['evaluation'] = float(
                            'inf') if mate_moves > 0 else float('-inf')
                        i += 3
                    else:
                        i += 1
                elif parts[i] == "nodes" and i + 1 < len(parts):
                    self.engine_results[engine_name]['nodes'] = int(
                        parts[i + 1])
                    i += 2
                elif parts[i] == "pv":
                    # Principal variation
                    pv = parts[i + 1:]
                    self.engine_results[engine_name]['pv'] = pv
                    break
                else:
                    i += 1

            # Callback cho UI n·∫øu c√≥ depth v√† evaluation
            if (self.engine_results[engine_name]['depth'] > 0 and
                    self.on_engine_result):
                self.on_engine_result(
                    engine_name, 'info', self.engine_results[engine_name])

        except Exception as e:
            print(f"‚ùå L·ªói parse info t·ª´ {engine_name}: {e}")
