# -*- coding: utf-8 -*-
"""
Main Window cho Xiangqi GUI
C·ª≠a s·ªï ch√≠nh ch·ª©a b√†n c·ªù v√† c√°c controls
"""

from PyQt5.QtWidgets import (QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
                             QMenuBar, QMenu, QAction, QStatusBar, QToolBar,
                             QLabel, QPushButton, QTextEdit, QSplitter,
                             QMessageBox, QApplication, QDesktopWidget, QFileDialog,
                             QTabWidget, QScrollArea)
from PyQt5.QtCore import Qt, pyqtSignal, pyqtSlot, QTimer
from PyQt5.QtGui import QIcon, QFont, QKeySequence

from .board_widget import BoardWidget
from .game_info_widget import GameInfoWidget
from .multi_engine_widget import MultiEngineWidget
from .dialogs import FenDialog
from ..core.game_state import GameState
from ..engine.ucci_protocol import UCCIEngineManager
from ..utils.constants import *


class MainWindow(QMainWindow):
    """C·ª≠a s·ªï ch√≠nh c·ªßa ·ª©ng d·ª•ng"""

    # Signals ƒë·ªÉ thread-safe communication
    engine_bestmove_signal = pyqtSignal(str)
    engine_info_signal = pyqtSignal(str)
    position_changed_signal = pyqtSignal(str, list)  # fen, moves

    def __init__(self):
        super().__init__()
        self.game_state = GameState()
        self.engine_manager = UCCIEngineManager()
        self.engine_log = []
        self.ignore_engine_info = False  # Flag ƒë·ªÉ ignore engine info sau khi t·∫Øt analysis
        self.chinese_move_notation = True  # Flag ƒë·ªÉ s·ª≠ d·ª•ng k√Ω hi·ªáu Trung Qu·ªëc

        self.init_ui()
        self.setup_connections()

    def init_ui(self):
        """Kh·ªüi t·∫°o giao di·ªán"""
        self.setWindowTitle("Xiangqi GUI - C·ªù T∆∞·ªõng")
        # K√≠ch th∆∞·ªõc ph√π h·ª£p v·ªõi layout nh·ªè g·ªçn nh∆∞ ·∫£nh tham kh·∫£o
        self.setMinimumSize(1000, 820)
        self.resize(1200, 820)  # K√≠ch th∆∞·ªõc m·∫∑c ƒë·ªãnh v·ª´a ph·∫£i

        # Center window on screen
        screen = QApplication.desktop().screenGeometry()
        size = self.geometry()
        self.move(
            (screen.width() - size.width()) // 2,
            (screen.height() - size.height()) // 2
        )

        # T·∫°o central widget v·ªõi splitter
        central_widget = QWidget()
        self.setCentralWidget(central_widget)

        # Main layout
        main_layout = QHBoxLayout(central_widget)
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(10)

        # Splitter ƒë·ªÉ chia layout
        splitter = QSplitter(Qt.Horizontal)

        main_layout.addWidget(splitter)

        # Left panel - Board (thu nh·ªè ƒë·ªÉ d√†nh kh√¥ng gian)
        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)
        left_layout.setContentsMargins(5, 5, 5, 5)

        # Board widget - thu nh·ªè canvas nh∆∞ trong ·∫£nh
        self.board_widget = BoardWidget()
        # Fixed size ƒë·ªÉ ƒë·∫£m b·∫£o t·ª∑ l·ªá
        # self.board_widget.setFixedSize(
        #     int(BOARD_SVG_WIDTH * BOARD_SCALE_FACTOR), int(BOARD_SVG_HEIGHT * BOARD_SCALE_FACTOR))
        left_layout.addWidget(self.board_widget)

        # Th√™m stretch ƒë·ªÉ board kh√¥ng b·ªã k√©o gi√£n
        left_layout.addStretch()

        # Right panel - S·ª≠ d·ª•ng TabWidget (tƒÉng k√≠ch th∆∞·ªõc nh∆∞ trong ·∫£nh)
        right_panel = QWidget()
        # right_panel.setMinimumWidth(450)  # TƒÉng ƒë·ªÉ chi·∫øm nhi·ªÅu kh√¥ng gian h∆°n
        # right_panel.setMaximumWidth(700)  # Cho ph√©p panel r·ªông h∆°n
        right_layout = QVBoxLayout(right_panel)
        right_layout.setContentsMargins(5, 5, 5, 5)
        right_layout.setSpacing(5)

        # N√∫t controls ·ªü tr√™n c√πng
        controls_layout = QHBoxLayout()
        self.new_game_btn = QPushButton("V√°n M·ªõi")
        self.undo_btn = QPushButton("Ho√†n T√°c")
        self.hint_btn = QPushButton("G·ª£i √ù")

        controls_layout.addWidget(self.new_game_btn)
        controls_layout.addWidget(self.undo_btn)
        controls_layout.addWidget(self.hint_btn)
        right_layout.addLayout(controls_layout)

        # Tab Widget cho c√°c panel kh√°c nhau
        self.tab_widget = QTabWidget()
        self.tab_widget.setTabPosition(QTabWidget.North)

        # Tab 1: Game Info
        game_info_tab = QWidget()
        game_info_layout = QVBoxLayout(game_info_tab)
        game_info_layout.setContentsMargins(5, 5, 5, 5)

        self.game_info_widget = GameInfoWidget()
        game_info_layout.addWidget(self.game_info_widget)

        self.tab_widget.addTab(game_info_tab, "üéÆ Th√¥ng Tin V√°n")

        # Tab 2: Multi-Engine Analysis
        multi_engine_tab = QWidget()
        multi_engine_layout = QVBoxLayout(multi_engine_tab)
        multi_engine_layout.setContentsMargins(5, 5, 5, 5)

        # Scroll area cho multi-engine widget
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)

        self.multi_engine_widget = MultiEngineWidget()
        scroll_area.setWidget(self.multi_engine_widget)
        multi_engine_layout.addWidget(scroll_area)

        self.tab_widget.addTab(multi_engine_tab, "ü§ñ Multi Engine")

        # Tab 3: Engine Log
        engine_log_tab = QWidget()
        engine_log_layout = QVBoxLayout(engine_log_tab)
        engine_log_layout.setContentsMargins(5, 5, 5, 5)

        self.engine_log = QTextEdit()
        self.engine_log.setPlaceholderText("Log giao ti·∫øp v·ªõi engine...")
        self.engine_log.setFont(QFont("Consolas", 9))  # Font monospace
        engine_log_layout.addWidget(self.engine_log)

        self.tab_widget.addTab(engine_log_tab, "üìã Engine Log")

        # Tab 4: Settings
        settings_tab = QWidget()
        settings_layout = QVBoxLayout(settings_tab)
        settings_layout.setContentsMargins(10, 10, 10, 10)
        settings_layout.setSpacing(15)

        # Board Settings Group
        board_group = QWidget()
        board_group_layout = QVBoxLayout(board_group)

        board_title = QLabel("üéØ C√†i ƒê·∫∑t B√†n C·ªù")
        board_title.setFont(QFont("Arial", 10, QFont.Bold))
        board_group_layout.addWidget(board_title)

        # Flip board button
        self.flip_board_btn = QPushButton("üîÑ L·∫≠t B√†n C·ªù")
        self.flip_board_btn.clicked.connect(self.flip_board)
        board_group_layout.addWidget(self.flip_board_btn)

        # Coordinate style button
        self.coord_style_btn = QPushButton(
            "üìç Toggle T·ªça ƒê·ªô (Trung Qu·ªëc/Qu·ªëc T·∫ø)")
        self.coord_style_btn.clicked.connect(self.toggle_coordinate_style)
        board_group_layout.addWidget(self.coord_style_btn)

        settings_layout.addWidget(board_group)

        # Move Notation Group
        notation_group = QWidget()
        notation_group_layout = QVBoxLayout(notation_group)

        notation_title = QLabel("üìù K√Ω Hi·ªáu N∆∞·ªõc ƒêi")
        notation_title.setFont(QFont("Arial", 10, QFont.Bold))
        notation_group_layout.addWidget(notation_title)

        self.notation_style_btn = QPushButton(
            "üî§ Toggle K√Ω Hi·ªáu (Trung Qu·ªëc/Qu·ªëc T·∫ø)")
        self.notation_style_btn.clicked.connect(
            self.toggle_move_notation_style)
        notation_group_layout.addWidget(self.notation_style_btn)

        settings_layout.addWidget(notation_group)

        # Engine Settings Group
        engine_group = QWidget()
        engine_group_layout = QVBoxLayout(engine_group)

        engine_title = QLabel("ü§ñ C√†i ƒê·∫∑t Engine")
        engine_title.setFont(QFont("Arial", 10, QFont.Bold))
        engine_group_layout.addWidget(engine_title)

        self.toggle_analysis_btn = QPushButton("üîç Toggle Ph√¢n T√≠ch Li√™n T·ª•c")
        self.toggle_analysis_btn.clicked.connect(self.toggle_engine_analysis)
        engine_group_layout.addWidget(self.toggle_analysis_btn)

        self.toggle_arrows_btn = QPushButton("üèπ Toggle M≈©i T√™n G·ª£i √ù")
        self.toggle_arrows_btn.clicked.connect(self.toggle_arrow_display)
        engine_group_layout.addWidget(self.toggle_arrows_btn)

        self.load_engine_btn = QPushButton("üìÅ Load Engine...")
        self.load_engine_btn.clicked.connect(self.load_engine_dialog)
        engine_group_layout.addWidget(self.load_engine_btn)

        settings_layout.addWidget(engine_group)

        # Add stretch to push everything to top
        settings_layout.addStretch()

        self.tab_widget.addTab(settings_tab, "‚öôÔ∏è C√†i ƒê·∫∑t")

        # Th√™m tab widget v√†o layout
        right_layout.addWidget(self.tab_widget)

        # Add panels to splitter
        splitter.addWidget(left_panel)
        splitter.addWidget(right_panel)

        # Set splitter proportions (40% board, 60% info) - nh∆∞ trong ·∫£nh tham kh·∫£o
        splitter.setSizes([400, 600])
        splitter.setCollapsible(0, False)  # Board kh√¥ng th·ªÉ collapse
        splitter.setCollapsible(1, False)  # Info panel kh√¥ng th·ªÉ collapse

        # T·∫°o menu bar
        self.create_menu_bar()

        # T·∫°o tool bar
        self.create_toolbar()

        # T·∫°o status bar
        self.status_bar = QStatusBar()
        self.setStatusBar(self.status_bar)
        self.status_bar.showMessage("S·∫µn s√†ng - L∆∞·ª£t c·ªßa ƒê·ªè")

    def create_menu_bar(self):
        """T·∫°o menu bar"""
        menubar = self.menuBar()

        # Menu File
        file_menu = menubar.addMenu('&File')

        # New game action
        new_game_action = QAction('&New Game', self)
        new_game_action.setShortcut('Ctrl+N')
        new_game_action.setStatusTip('B·∫Øt ƒë·∫ßu v√°n c·ªù m·ªõi')
        new_game_action.triggered.connect(self.new_game)
        file_menu.addAction(new_game_action)

        file_menu.addSeparator()

        # FEN actions
        load_fen_action = QAction('&Load FEN...', self)
        load_fen_action.setShortcut('Ctrl+L')
        load_fen_action.setStatusTip('Load position t·ª´ FEN notation')
        load_fen_action.triggered.connect(self.show_fen_dialog)
        file_menu.addAction(load_fen_action)

        copy_fen_action = QAction('&Copy FEN', self)
        copy_fen_action.setShortcut('Ctrl+C')
        copy_fen_action.setStatusTip('Copy FEN c·ªßa position hi·ªán t·∫°i')
        copy_fen_action.triggered.connect(self.copy_current_fen)
        file_menu.addAction(copy_fen_action)

        file_menu.addSeparator()

        # Exit action
        exit_action = QAction('&Exit', self)
        exit_action.setShortcut('Ctrl+Q')
        exit_action.setStatusTip('Tho√°t ch∆∞∆°ng tr√¨nh')
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)

        # Menu Engine
        engine_menu = menubar.addMenu('&Engine')

        load_engine_action = QAction('&Load Engine...', self)
        load_engine_action.setStatusTip('Load engine c·ªù t∆∞·ªõng')
        load_engine_action.triggered.connect(self.load_engine_dialog)
        engine_menu.addAction(load_engine_action)

        engine_menu.addSeparator()

        toggle_hints_action = QAction('&Toggle M≈©i T√™n', self)
        toggle_hints_action.setCheckable(True)
        toggle_hints_action.setChecked(True)
        toggle_hints_action.setStatusTip('B·∫≠t/t·∫Øt hi·ªÉn th·ªã m≈©i t√™n g·ª£i √Ω')
        toggle_hints_action.triggered.connect(self.toggle_arrow_display)
        engine_menu.addAction(toggle_hints_action)

        # L∆∞u reference ƒë·ªÉ s·ª≠ d·ª•ng trong c√°c method kh√°c
        self.arrow_action = toggle_hints_action

        # Protocol selection
        # Protocol auto-detection (kh√¥ng c·∫ßn toggle n·ªØa)

        # Menu View
        view_menu = menubar.addMenu('&Hi·ªÉn Th·ªã')

        # Flip board action
        flip_board_action = QAction('&L·∫≠t B√†n C·ªù', self)
        flip_board_action.setShortcut('Ctrl+F')
        flip_board_action.setStatusTip(
            'L·∫≠t b√†n c·ªù (xem t·ª´ g√≥c nh√¨n ƒë·ªëi ph∆∞∆°ng)')
        flip_board_action.triggered.connect(self.flip_board)
        view_menu.addAction(flip_board_action)

        view_menu.addSeparator()

        # Toggle coordinate style action
        toggle_coords_action = QAction('&T·ªça ƒê·ªô Ki·ªÉu Trung Qu·ªëc', self)
        toggle_coords_action.setCheckable(True)
        toggle_coords_action.setChecked(True)
        toggle_coords_action.setStatusTip(
            'Chuy·ªÉn ƒë·ªïi gi·ªØa t·ªça ƒë·ªô a-i/0-9 v√† 1-9 ki·ªÉu Trung Qu·ªëc')
        toggle_coords_action.triggered.connect(self.toggle_coordinate_style)
        view_menu.addAction(toggle_coords_action)

        # Toggle move notation style action
        toggle_move_notation_action = QAction(
            '&K√Ω Hi·ªáu N∆∞·ªõc ƒêi Trung Qu·ªëc', self)
        toggle_move_notation_action.setCheckable(True)
        toggle_move_notation_action.setChecked(True)
        toggle_move_notation_action.setStatusTip(
            'Chuy·ªÉn ƒë·ªïi gi·ªØa a1‚Üíb2 v√† "t∆∞·ªõng 5 t·∫•n 1"')
        toggle_move_notation_action.triggered.connect(
            self.toggle_move_notation_style)
        view_menu.addAction(toggle_move_notation_action)

        # L∆∞u reference ƒë·ªÉ s·ª≠ d·ª•ng sau
        self.coords_action = toggle_coords_action
        self.move_notation_action = toggle_move_notation_action

        # Menu Help
        help_menu = menubar.addMenu('&Tr·ª£ Gi√∫p')

        about_action = QAction('&V·ªÅ Ch∆∞∆°ng Tr√¨nh...', self)
        about_action.triggered.connect(self.show_about)
        help_menu.addAction(about_action)

    def create_toolbar(self):
        """T·∫°o toolbar v·ªõi c√°c n√∫t th∆∞·ªùng d√πng"""
        toolbar = self.addToolBar("Main")
        toolbar.setMovable(False)

        # New game button
        new_action = QAction("V√°n M·ªõi", self)
        new_action.setShortcut("Ctrl+N")
        new_action.triggered.connect(self.new_game)
        toolbar.addAction(new_action)

        toolbar.addSeparator()

        # Undo button
        undo_action = QAction("Ho√†n T√°c", self)
        undo_action.setShortcut("Ctrl+Z")
        undo_action.triggered.connect(self.undo_move)
        toolbar.addAction(undo_action)

        # Redo button
        redo_action = QAction("L√†m L·∫°i", self)
        redo_action.setShortcut("Ctrl+Y")
        redo_action.triggered.connect(self.redo_move)
        toolbar.addAction(redo_action)

        toolbar.addSeparator()

        # Engine analysis
        self.analyze_action = QAction("Ph√¢n T√≠ch", self)
        self.analyze_action.setCheckable(True)  # Cho ph√©p toggle state
        self.analyze_action.triggered.connect(self.toggle_engine_analysis)
        toolbar.addAction(self.analyze_action)

    def setup_connections(self):
        """Thi·∫øt l·∫≠p k·∫øt n·ªëi signals/slots"""
        # K·∫øt n·ªëi board widget signals
        self.board_widget.piece_moved.connect(self.on_piece_moved)
        self.board_widget.square_clicked.connect(self.on_square_clicked)
        self.board_widget.move_made.connect(self.on_move_made)

        # Multi-engine connections
        self.multi_engine_widget.hint_selected.connect(
            self.on_multi_engine_hint_selected)
        self.multi_engine_widget.engine_arrows_changed.connect(
            self.on_multi_engine_arrows_changed)

        # K·∫øt n·ªëi signal position changed ƒë·ªÉ t·ª± ƒë·ªông c·∫≠p nh·∫≠t multi-engine
        self.position_changed_signal.connect(
            self.multi_engine_widget.set_position)
        print(
            f"üîó [SETUP] Connected position_changed_signal to multi_engine_widget.set_position")
        print(f"üîó [SETUP] Signal connection completed")

        # K·∫øt n·ªëi button signals
        self.new_game_btn.clicked.connect(self.new_game)
        self.undo_btn.clicked.connect(self.undo_move)
        self.hint_btn.clicked.connect(self.get_hint)

        # K·∫øt n·ªëi engine signals (thread-safe)
        self.engine_bestmove_signal.connect(self.handle_engine_bestmove)
        self.engine_info_signal.connect(self.handle_engine_info)

        # Set initial position cho multi-engine widget
        self._emit_position_changed()

        # B·∫≠t l·∫°i arrow display
        self.arrow_action.setChecked(True)

    def _emit_position_changed(self):
        """Emit signal khi position thay ƒë·ªïi"""
        current_fen = self.game_state.to_fen()
        if current_fen:
            engine_moves = self.convert_moves_to_engine_notation(
                self.game_state.move_history)
            print(f"üì° Position changed: {len(engine_moves)} moves")
            if engine_moves:
                # Show last 3 moves
                print(f"üìù Latest moves: {engine_moves[-3:]}")
            self.position_changed_signal.emit(current_fen, engine_moves)
        else:
            print(f"‚ùå [SIGNAL] Cannot emit - no FEN available")

    def new_game(self):
        """B·∫Øt ƒë·∫ßu v√°n c·ªù m·ªõi"""
        self.game_state.reset()
        self.board_widget.reset_board()
        self.game_info_widget.reset()

        # ƒê·ªìng b·ªô current_player v·ªõi BoardWidget
        self.board_widget.set_current_player(self.game_state.current_player)

        # Clear engine hint
        self.board_widget.clear_engine_hint()

        # T·∫Øt analysis mode n·∫øu ƒëang b·∫≠t
        if hasattr(self, 'analysis_enabled') and self.analysis_enabled:
            self.analysis_enabled = False
            self.analyze_action.setChecked(False)

        # Reset v√† reload engine n·∫øu c√≥
        if self.engine_manager.get_current_engine():
            current_engine_name = None
            current_engine_path = None

            # L∆∞u th√¥ng tin engine hi·ªán t·∫°i
            for name, engine in self.engine_manager.engines.items():
                if engine == self.engine_manager.current_engine:
                    current_engine_name = name
                    current_engine_path = engine.engine_path
                    break

            if current_engine_name and current_engine_path:
                # D·ª´ng v√† x√≥a engine hi·ªán t·∫°i
                self.engine_manager.get_current_engine().stop()
                del self.engine_manager.engines[current_engine_name]
                self.engine_manager.current_engine = None

                # Reset arrow state v·ªÅ false tr∆∞·ªõc khi restart
                if hasattr(self, 'arrow_action'):
                    self.arrow_action.setChecked(False)

                # Load l·∫°i engine t·ª´ ƒë·∫ßu
                success = self.engine_manager.add_engine(
                    current_engine_name, current_engine_path)
                if success:
                    self.engine_manager.set_current_engine(current_engine_name)
                    engine = self.engine_manager.get_current_engine()

                    # Setup callbacks
                    engine.on_bestmove = self.on_engine_bestmove
                    engine.on_info = self.on_engine_info

                    # Set position t·ª´ FEN
                    engine.set_position(self.game_state.to_fen())

                self.update_status(
                    f"‚úì V√°n c·ªù m·ªõi ƒë√£ b·∫Øt ƒë·∫ßu - Engine {current_engine_name} ƒë√£ ƒë∆∞·ª£c restart")
            else:
                self.update_status("‚úì V√°n c·ªù m·ªõi ƒë√£ b·∫Øt ƒë·∫ßu - L∆∞·ª£t c·ªßa ƒê·ªè")
        else:
            self.update_status("‚úì V√°n c·ªù m·ªõi ƒë√£ b·∫Øt ƒë·∫ßu - L∆∞·ª£t c·ªßa ƒê·ªè")

        # Update position cho multi-engine widget v·ªõi starting position
        self._emit_position_changed()

        # B·∫≠t l·∫°i arrow display
        self.arrow_action.setChecked(True)

    def load_engine(self):
        """T·∫£i engine t·ª´ file"""
        # TODO: Implement file dialog to select engine
        # T·∫°m th·ªùi hardcode path ƒë·ªÉ test
        engine_path = "./engines/Fairy-Stockfish/fairy-stockfish"  # V√≠ d·ª•

        success = self.engine_manager.add_engine(
            "Fairy-Stockfish", engine_path)
        if success:
            self.engine_manager.set_current_engine("Fairy-Stockfish")
            engine = self.engine_manager.get_current_engine()

            # Setup callbacks
            engine.on_bestmove = self.on_engine_bestmove
            engine.on_info = self.on_engine_info

            self.update_status("Engine ƒë√£ ƒë∆∞·ª£c t·∫£i th√†nh c√¥ng")
        else:
            self.update_status("L·ªói: Kh√¥ng th·ªÉ t·∫£i engine")

    def on_piece_moved(self, from_pos, to_pos):
        """X·ª≠ l√Ω khi qu√¢n c·ªù ƒë∆∞·ª£c di chuy·ªÉn (deprecated - s·ª≠ d·ª•ng on_move_made thay th·∫ø)"""
        # Method n√†y kh√¥ng ƒë∆∞·ª£c s·ª≠ d·ª•ng n·ªØa, ƒë√£ chuy·ªÉn sang on_move_made
        print(
            f"‚ö†Ô∏è Deprecated method on_piece_moved ƒë∆∞·ª£c g·ªçi: {from_pos} -> {to_pos}")
        pass

    def on_square_clicked(self, position):
        """X·ª≠ l√Ω khi click v√†o √¥ c·ªù"""
        print(f"Square clicked: {position}")

    def on_move_made(self, from_row, from_col, to_row, to_col):
        """X·ª≠ l√Ω khi th·ª±c hi·ªán n∆∞·ªõc ƒëi h·ª£p l·ªá"""
        # S·ª≠ d·ª•ng GameState ƒë·ªÉ th·ª±c hi·ªán n∆∞·ªõc ƒëi (ƒë√£ bao g·ªìm validation v√† history tracking)
        if self.game_state.make_move(from_row, from_col, to_row, to_col):
            # ƒê·ªìng b·ªô current_player v·ªõi BoardWidget
            self.board_widget.set_current_player(
                self.game_state.current_player)

            # L·∫•y th√¥ng tin move ƒë·ªÉ hi·ªÉn th·ªã
            # Piece ƒë√£ ƒë∆∞·ª£c di chuy·ªÉn
            piece = self.game_state.board[to_row][to_col]
            captured_piece = self.game_state.captured_pieces[-1] if self.game_state.captured_pieces else None
            move_notation = self.game_state.move_history[-1] if self.game_state.move_history else ""

            # Update UI v·ªõi notation ƒë√∫ng
            piece_name = self.get_piece_name(piece)

            # Format move d·ª±a tr√™n style ƒë√£ ch·ªçn
            if self.chinese_move_notation:
                # S·ª≠ d·ª•ng Chinese notation
                from ..utils.constants import format_move_chinese_style
                formatted_move = format_move_chinese_style(
                    piece, from_row, from_col, to_row, to_col,
                    'red' if piece.isupper() else 'black')
            else:
                # S·ª≠ d·ª•ng international notation
                formatted_move = self.format_move_notation(
                    move_notation, is_engine_notation=False)

            if captured_piece:
                status_msg = f"‚úì {piece_name} {formatted_move} - B·∫Øt {self.get_piece_name(captured_piece)}"
            else:
                status_msg = f"‚úì {piece_name} {formatted_move}"

            self.update_status(status_msg)

            # Update game info v·ªõi formatted move
            self.game_info_widget.add_move(formatted_move)
            self.game_info_widget.set_current_player(
                self.game_state.current_player)

            # Clear previous engine hint
            self.board_widget.clear_engine_hint()

            # Check for game end conditions
            self.check_game_end()

            # Update position cho multi-engine widget (lu√¥n c·∫≠p nh·∫≠t b·∫•t k·ªÉ c√≥ engine th∆∞·ªùng hay kh√¥ng)
            self._emit_position_changed()

            # Send move to engine (ch·ªâ khi c√≥ engine th∆∞·ªùng)
            if self.engine_manager.get_current_engine():
                engine = self.engine_manager.get_current_engine()

                # Update position v·ªõi move history
                current_fen = self.game_state.to_fen()
                engine_moves = self.convert_moves_to_engine_notation(
                    self.game_state.move_history)

                if current_fen:
                    engine.set_position(current_fen, engine_moves)

                # N·∫øu analysis mode b·∫≠t, ph√¢n t√≠ch position m·ªõi
                if hasattr(self, 'analysis_enabled') and self.analysis_enabled:
                    # D·ª´ng analysis c≈© v√† b·∫Øt ƒë·∫ßu m·ªõi
                    engine.stop_search()
                    self.ignore_engine_info = True
                    QTimer.singleShot(100, lambda: self.start_new_analysis(
                        engine, current_fen, engine_moves))
        else:
            self.update_status("‚ùå N∆∞·ªõc ƒëi kh√¥ng h·ª£p l·ªá")

    def get_piece_name(self, piece):
        """L·∫•y t√™n ti·∫øng Vi·ªát c·ªßa qu√¢n c·ªù"""
        piece_names = {
            'K': 'T∆∞·ªõng', 'k': 'T∆∞·ªõng',
            'A': 'Sƒ©', 'a': 'Sƒ©',
            'B': 'T∆∞·ª£ng', 'b': 'T∆∞·ª£ng',
            'N': 'M√£', 'n': 'M√£',
            'R': 'Xe', 'r': 'Xe',
            'C': 'Ph√°o', 'c': 'Ph√°o',
            'P': 'T·ªët', 'p': 'T·ªët'
        }
        return piece_names.get(piece, piece)

    def check_game_end(self):
        """Ki·ªÉm tra ƒëi·ªÅu ki·ªán k·∫øt th√∫c game"""
        # TODO: Implement checkmate, stalemate detection
        pass

    def on_engine_bestmove(self, move):
        """X·ª≠ l√Ω khi engine tr·∫£ v·ªÅ n∆∞·ªõc ƒëi t·ªët nh·∫•t"""
        # Emit signal for thread-safe communication
        self.engine_bestmove_signal.emit(move)

    def on_engine_info(self, info):
        """X·ª≠ l√Ω th√¥ng tin t·ª´ engine"""
        # Emit signal for thread-safe communication
        self.engine_info_signal.emit(info)

    @pyqtSlot(str)
    def handle_engine_info(self, info):
        """Thread-safe x·ª≠ l√Ω info t·ª´ engine"""
        # Ki·ªÉm tra n·∫øu ƒëang ignore engine info (sau khi t·∫Øt analysis)
        if hasattr(self, 'ignore_engine_info') and self.ignore_engine_info:
            return

        # Parse engine info v√† c·∫≠p nh·∫≠t game info widget
        if "depth" in info or "score" in info or "pv" in info:
            self.engine_log.append(info)

            # Parse th√¥ng tin t·ª´ engine info
            info_data = self.parse_engine_info(info)
            if info_data:
                self.game_info_widget.set_engine_info(**info_data)

                # N·∫øu analysis mode b·∫≠t v√† c√≥ PV, c·∫≠p nh·∫≠t m≈©i t√™n
                if (hasattr(self, 'analysis_enabled') and self.analysis_enabled and
                        'pv' in info_data and info_data['pv'] and self.arrow_action.isChecked()):

                    # L·∫•y n∆∞·ªõc ƒëi ƒë·∫ßu ti√™n t·ª´ PV l√†m best move
                    best_move = info_data['pv'][0] if info_data['pv'] else None
                    ponder_move = info_data['pv'][1] if len(
                        info_data['pv']) > 1 else None

                    if best_move:
                        # C·∫≠p nh·∫≠t m≈©i t√™n analysis
                        self.board_widget.set_engine_hint(
                            best_move, ponder_move)

                        # Update status v·ªõi depth info
                        depth = info_data.get('depth', '?')
                        eval_str = info_data.get('evaluation', '?')
                        self.update_status(
                            f"üîç Ph√¢n t√≠ch depth {depth}: {best_move} (eval: {eval_str})")

    @pyqtSlot(str)
    def handle_engine_bestmove(self, bestmove_line):
        """Thread-safe x·ª≠ l√Ω bestmove t·ª´ engine"""
        # Lu√¥n x·ª≠ l√Ω bestmove ƒë·ªÉ log v√† update info
        if bestmove_line:
            print(f"ÔøΩÔøΩ Engine response: {bestmove_line}")

            # Parse bestmove line: "bestmove b0c2 ponder g6g5"
            parts = bestmove_line.strip().split()
            bestmove = None
            ponder = None

            for i, part in enumerate(parts):
                if part == "bestmove" and i + 1 < len(parts):
                    bestmove = parts[i + 1]
                elif part == "ponder" and i + 1 < len(parts):
                    ponder = parts[i + 1]

            if bestmove:
                # Ch·ªâ v·∫Ω m≈©i t√™n khi arrow display b·∫≠t
                if self.arrow_action.isChecked():
                    # Hi·ªÉn th·ªã hint tr√™n board v·ªõi c·∫£ bestmove v√† ponder
                    self.board_widget.set_engine_hint(bestmove, ponder)

                # Update status v·ªõi m√†u t∆∞∆°ng ·ª©ng
                player_name = "ƒê·ªè" if self.game_state.current_player == 'red' else "ƒêen"
                arrow_color = "t√≠m" if self.game_state.current_player == 'red' else "xanh"

                status_msg = f"ü§ñ Engine g·ª£i √Ω cho {player_name} (m≈©i t√™n {arrow_color}): {bestmove}"
                if ponder:
                    opponent_name = "ƒêen" if self.game_state.current_player == 'red' else "ƒê·ªè"
                    ponder_color = "xanh" if self.game_state.current_player == 'red' else "t√≠m"
                    status_msg += f", d·ª± ƒëo√°n {opponent_name} (ƒë·ª©t n√©t {ponder_color}): {ponder}"

                self.update_status(status_msg)

            # Log v√†o engine log cho c·∫£ 2 mode
            log_msg = f"Engine ƒë·ªÅ xu·∫•t: {bestmove}"
            if ponder:
                log_msg += f", d·ª± ƒëo√°n: {ponder}"
            self.engine_log.append(log_msg)

            # C·∫≠p nh·∫≠t best move trong game info widget cho c·∫£ 2 mode
            formatted_move = self.format_move_notation(
                bestmove, is_engine_notation=True)
            self.game_info_widget.set_engine_info(best_move=formatted_move)

    def parse_engine_info(self, info_line):
        """
        Parse th√¥ng tin t·ª´ engine info line

        Args:
            info_line: D√≤ng info t·ª´ engine

        Returns:
            dict: Th√¥ng tin ƒë√£ parse ho·∫∑c None
        """
        try:
            parts = info_line.split()
            if not parts or parts[0] != "info":
                return None

            info_data = {}
            i = 1

            while i < len(parts):
                key = parts[i]

                if key == "depth" and i + 1 < len(parts):
                    info_data['depth'] = int(parts[i + 1])
                    i += 2

                elif key == "score" and i + 2 < len(parts):
                    score_type = parts[i + 1]  # "cp" ho·∫∑c "mate"
                    score_value = parts[i + 2]

                    if score_type == "cp":
                        # Centipawn score
                        cp_score = int(score_value)
                        # Chuy·ªÉn ƒë·ªïi t·ª´ centipawn sang pawn (chia 100)
                        info_data['evaluation'] = cp_score / 100.0
                    elif score_type == "mate":
                        # Mate in X moves
                        mate_moves = int(score_value)
                        if mate_moves > 0:
                            info_data['evaluation'] = f"Chi·∫øu t∆∞·ªõng trong {mate_moves} n∆∞·ªõc"
                        else:
                            info_data['evaluation'] = f"B·ªã chi·∫øu t∆∞·ªõng trong {abs(mate_moves)} n∆∞·ªõc"
                    i += 3

                elif key == "nodes" and i + 1 < len(parts):
                    info_data['nodes'] = int(parts[i + 1])
                    i += 2

                elif key == "nps" and i + 1 < len(parts):
                    info_data['nps'] = int(parts[i + 1])
                    i += 2

                elif key == "time" and i + 1 < len(parts):
                    info_data['time_ms'] = int(parts[i + 1])
                    i += 2

                elif key == "pv":
                    # Principal variation - l·∫•y t·∫•t c·∫£ moves c√≤n l·∫°i
                    pv_moves = parts[i + 1:]
                    info_data['pv'] = pv_moves
                    break

                else:
                    i += 1

            return info_data if info_data else None

        except (ValueError, IndexError) as e:
            print(f"‚ùå L·ªói parse engine info: {e}")
            return None

    def undo_move(self):
        """Ho√†n t√°c n∆∞·ªõc ƒëi"""
        if self.game_state.can_undo():
            # L∆∞u th√¥ng tin move tr∆∞·ªõc khi undo
            last_move = self.game_state.move_history[-1] if self.game_state.move_history else "unknown"

            # Undo trong GameState
            if self.game_state.undo_move():
                # ƒê·ªìng b·ªô board v·ªõi BoardWidget
                self.board_widget.board_state = [row[:]
                                                 for row in self.game_state.board]
                self.board_widget.set_current_player(
                    self.game_state.current_player)
                self.board_widget.selected_square = None
                self.board_widget.possible_moves = []
                self.board_widget.update()

                # Update UI
                self.game_info_widget.remove_last_move()
                self.game_info_widget.set_current_player(
                    self.game_state.current_player)

                self.update_status(f"‚úì ƒê√£ ho√†n t√°c n∆∞·ªõc ƒëi: {last_move}")

                # Sync v·ªõi engine
                if self.engine_manager.get_current_engine():
                    engine = self.engine_manager.get_current_engine()
                    current_fen = self.game_state.to_fen()
                    if current_fen:
                        engine_moves = self.convert_moves_to_engine_notation(
                            self.game_state.move_history)
                        engine.set_position(current_fen, engine_moves)

                    # N·∫øu analysis mode b·∫≠t, ph√¢n t√≠ch position m·ªõi
                    if hasattr(self, 'analysis_enabled') and self.analysis_enabled:
                        # D·ª´ng analysis c≈© v√† b·∫Øt ƒë·∫ßu m·ªõi
                        engine.stop_search()
                        self.ignore_engine_info = True
                        QTimer.singleShot(100, lambda: self.start_new_analysis(
                            engine, current_fen, engine_moves))

                # Update position cho multi-engine widget
                self._emit_position_changed()
            else:
                self.update_status("‚ùå Kh√¥ng th·ªÉ ho√†n t√°c")
        else:
            self.update_status("‚ùå Kh√¥ng c√≥ n∆∞·ªõc ƒëi ƒë·ªÉ ho√†n t√°c")

    def redo_move(self):
        """L√†m l·∫°i n∆∞·ªõc ƒëi"""
        if self.game_state.can_redo():
            # L∆∞u th√¥ng tin move tr∆∞·ªõc khi redo
            next_move = self.game_state.redo_move_history[-1] if self.game_state.redo_move_history else "unknown"

            # Redo trong GameState
            if self.game_state.redo_move():
                # ƒê·ªìng b·ªô board v·ªõi BoardWidget
                self.board_widget.board_state = [row[:]
                                                 for row in self.game_state.board]
                self.board_widget.set_current_player(
                    self.game_state.current_player)
                self.board_widget.selected_square = None
                self.board_widget.possible_moves = []
                self.board_widget.update()

                # Update UI
                self.game_info_widget.set_current_player(
                    self.game_state.current_player)

                # Update move trong game info (th√™m l·∫°i move)
                formatted_move = self.format_move_notation(
                    next_move, is_engine_notation=False)
                self.game_info_widget.add_move(formatted_move)

                self.update_status(f"‚úì L√†m l·∫°i n∆∞·ªõc ƒëi: {formatted_move}")

                # Sync v·ªõi engine
                if self.engine_manager.get_current_engine():
                    engine = self.engine_manager.get_current_engine()
                    current_fen = self.game_state.to_fen()
                    if current_fen:
                        engine_moves = self.convert_moves_to_engine_notation(
                            self.game_state.move_history)
                        engine.set_position(current_fen, engine_moves)

                    # N·∫øu analysis mode b·∫≠t, ph√¢n t√≠ch position m·ªõi
                    if hasattr(self, 'analysis_enabled') and self.analysis_enabled:
                        # D·ª´ng analysis c≈© v√† b·∫Øt ƒë·∫ßu m·ªõi
                        engine.stop_search()
                        self.ignore_engine_info = True
                        QTimer.singleShot(100, lambda: self.start_new_analysis(
                            engine, current_fen, engine_moves))

                # Update position cho multi-engine widget
                self._emit_position_changed()
            else:
                self.update_status("‚ùå Kh√¥ng th·ªÉ l√†m l·∫°i n∆∞·ªõc ƒëi")
        else:
            self.update_status("‚ùå Kh√¥ng c√≥ n∆∞·ªõc ƒëi ƒë·ªÉ l√†m l·∫°i")

    def update_turn_label(self):
        """C·∫≠p nh·∫≠t label hi·ªÉn th·ªã l∆∞·ª£t ch∆°i"""
        current_player = "ƒê·ªè" if self.game_state.current_player == "red" else "ƒêen"
        self.status_bar.showMessage(f"S·∫µn s√†ng - L∆∞·ª£t c·ªßa {current_player}")

    def update_status(self, message):
        """C·∫≠p nh·∫≠t status bar"""
        self.status_bar.showMessage(message)

    def show_about(self):
        """Hi·ªÉn th·ªã dialog v·ªÅ ch∆∞∆°ng tr√¨nh"""
        # TODO: Implement about dialog
        pass

    def closeEvent(self, event):
        """X·ª≠ l√Ω khi ƒë√≥ng ·ª©ng d·ª•ng"""
        try:
            # D·ª´ng t·∫•t c·∫£ engine tr∆∞·ªõc khi tho√°t
            if hasattr(self, 'engine_manager'):
                self.engine_manager.stop_all_engines()

            # Clear engine log ƒë·ªÉ gi·∫£i ph√≥ng b·ªô nh·ªõ
            if hasattr(self, 'engine_log'):
                self.engine_log.clear()

            # Disconnect signals
            if hasattr(self, 'engine_bestmove_signal'):
                self.engine_bestmove_signal.disconnect()
            if hasattr(self, 'engine_info_signal'):
                self.engine_info_signal.disconnect()

            print("Cleanup ho√†n th√†nh")
        except Exception as e:
            print(f"L·ªói trong cleanup: {e}")
        finally:
            event.accept()

    def show_fen_dialog(self):
        """Hi·ªÉn th·ªã dialog ƒë·ªÉ nh·∫≠p FEN"""
        current_fen = self.board_widget.get_current_fen()
        fen_dialog = FenDialog(self, current_fen)

        if fen_dialog.exec_() == fen_dialog.Accepted:
            fen = fen_dialog.get_result_fen()
            if fen and self.board_widget.load_fen_position(fen):
                # Update game state
                self.game_state.load_from_fen(fen)
                self.game_info_widget.reset()

                # T·∫Øt analysis mode n·∫øu ƒëang b·∫≠t
                if hasattr(self, 'analysis_enabled') and self.analysis_enabled:
                    self.analysis_enabled = False
                    self.analyze_action.setChecked(False)

                # Clear engine hint
                self.board_widget.clear_engine_hint()

                # Reset engine v·ªõi position m·ªõi
                if self.engine_manager.get_current_engine():
                    current_engine_name = None
                    current_engine_path = None

                    # L∆∞u th√¥ng tin engine hi·ªán t·∫°i
                    for name, engine in self.engine_manager.engines.items():
                        if engine == self.engine_manager.current_engine:
                            current_engine_name = name
                            current_engine_path = engine.engine_path
                            break

                    if current_engine_name and current_engine_path:
                        # D·ª´ng v√† x√≥a engine hi·ªán t·∫°i
                        self.engine_manager.get_current_engine().stop()
                        del self.engine_manager.engines[current_engine_name]
                        self.engine_manager.current_engine = None

                        # Reset arrow state v·ªÅ false tr∆∞·ªõc khi restart
                        if hasattr(self, 'arrow_action'):
                            self.arrow_action.setChecked(False)

                        # Load l·∫°i engine t·ª´ ƒë·∫ßu
                        success = self.engine_manager.add_engine(
                            current_engine_name, current_engine_path)
                        if success:
                            self.engine_manager.set_current_engine(
                                current_engine_name)
                            engine = self.engine_manager.get_current_engine()

                            # Setup callbacks
                            engine.on_bestmove = self.on_engine_bestmove
                            engine.on_info = self.on_engine_info

                            # Set position t·ª´ FEN
                            engine.set_position(fen)

                # Update position cho multi-engine widget
                self._emit_position_changed()

                self.update_status(
                    "‚úì ƒê√£ load position t·ª´ FEN - Engine ƒë√£ ƒë∆∞·ª£c restart")
            else:
                self.update_status("‚ùå Kh√¥ng th·ªÉ load FEN")

    def copy_current_fen(self):
        """Copy FEN c·ªßa v·ªã tr√≠ hi·ªán t·∫°i"""
        fen = self.game_state.to_fen()
        QApplication.clipboard().setText(fen)
        self.update_status("FEN ƒë√£ ƒë∆∞·ª£c sao ch√©p v√†o clipboard")

    def toggle_engine_analysis(self):
        """Toggle engine analysis mode on/off"""
        if not hasattr(self, 'analysis_enabled'):
            self.analysis_enabled = False

        self.analysis_enabled = not self.analysis_enabled

        # Update visual state c·ªßa button
        self.analyze_action.setChecked(self.analysis_enabled)

        if not self.analysis_enabled:
            # T·∫Øt analysis - d·ª´ng engine v√† clear arrows
            if self.engine_manager.get_current_engine():
                engine = self.engine_manager.get_current_engine()
                engine.stop_search()

            # Clear analysis arrows n·∫øu arrow display t·∫Øt
            if not self.arrow_action.isChecked():
                self.board_widget.clear_engine_hint()

            # Set flag ƒë·ªÉ ignore th√¥ng tin engine c≈©
            self.ignore_engine_info = True

            # D√πng QTimer ƒë·ªÉ reset flag sau m·ªôt kho·∫£ng th·ªùi gian ng·∫Øn
            QTimer.singleShot(200, lambda: setattr(
                self, 'ignore_engine_info', False))

            self.update_status("üîç ƒê√£ t·∫Øt ph√¢n t√≠ch li√™n t·ª•c")
        else:
            # Reset flag ƒë·ªÉ nh·∫≠n th√¥ng tin engine m·ªõi
            self.ignore_engine_info = False

            # B·∫≠t analysis - b·∫Øt ƒë·∫ßu continuous analysis
            if self.engine_manager.get_current_engine():
                engine = self.engine_manager.get_current_engine()
                current_fen = self.game_state.to_fen()
                if current_fen:
                    engine_moves = self.convert_moves_to_engine_notation(
                        self.game_state.move_history)
                    engine.set_position(current_fen, engine_moves)
                    # B·∫Øt ƒë·∫ßu continuous analysis (kh√¥ng c√≥ depth limit)
                    engine.go_infinite()  # Ph√¢n t√≠ch v√¥ h·∫°n
                self.update_status("üîç ƒê√£ b·∫≠t ph√¢n t√≠ch li√™n t·ª•c")
            else:
                # Reset button state n·∫øu kh√¥ng c√≥ engine
                self.analysis_enabled = False
                self.analyze_action.setChecked(False)
                self.update_status("‚ùå C·∫ßn load engine tr∆∞·ªõc khi ph√¢n t√≠ch")

    def toggle_arrow_display(self):
        """Toggle arrow display on/off"""
        if not self.arrow_action.isChecked():
            # T·∫Øt arrow display
            self.board_widget.clear_engine_hint()
            self.update_status("‚û°Ô∏è ƒê√£ t·∫Øt hi·ªÉn th·ªã m≈©i t√™n")
        else:
            # B·∫≠t arrow display - request hint n·∫øu c√≥ engine
            self.update_status("‚û°Ô∏è ƒê√£ b·∫≠t hi·ªÉn th·ªã m≈©i t√™n")
            if self.engine_manager.get_current_engine():
                engine = self.engine_manager.get_current_engine()
                current_fen = self.game_state.to_fen()
                if current_fen:
                    engine_moves = self.convert_moves_to_engine_notation(
                        self.game_state.move_history)
                    engine.set_position(current_fen, engine_moves)
                    engine.get_hint(depth=15)

    def load_engine_dialog(self):
        """Hi·ªÉn th·ªã dialog ƒë·ªÉ ch·ªçn engine file"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Ch·ªçn Engine C·ªù T∆∞·ªõng",
            "./engines/",
            "Executable Files All Files (*)"
        )

        if file_path:
            self.load_engine_from_path(file_path)

    def load_engine_from_path(self, engine_path):
        """Load engine t·ª´ ƒë∆∞·ªùng d·∫´n"""
        engine_name = f"Engine_{len(self.engine_manager.engines) + 1}"

        success = self.engine_manager.add_engine(engine_name, engine_path)
        if success:
            self.engine_manager.set_current_engine(engine_name)
            engine = self.engine_manager.get_current_engine()

            # Setup callbacks
            engine.on_bestmove = self.on_engine_bestmove
            engine.on_info = self.on_engine_info

            self.update_status(f"‚úì Engine ƒë√£ ƒë∆∞·ª£c t·∫£i: {engine_path}")

            # Ch·ªâ request hint n·∫øu hints mode ƒëang b·∫≠t
            if self.arrow_action.isChecked():
                current_fen = self.game_state.to_fen()
                if current_fen:
                    engine.set_position(current_fen)
                    engine.get_hint(depth=15)
        else:
            self.update_status(f"‚ùå Kh√¥ng th·ªÉ t·∫£i engine: {engine_path}")

    def format_move_notation(self, move, is_engine_notation=False):
        """
        Format move notation cho d·ªÖ ƒë·ªçc

        Args:
            move: Move notation (e.g., "c2d2")
            is_engine_notation: True n·∫øu move d√πng engine notation (0-9), False n·∫øu board notation (0-9)

        Returns:
            str: Formatted move
        """
        if not move or len(move) != 4:
            return move

        try:
            # Parse move
            from_file = move[0]
            from_rank = int(move[1])
            to_file = move[2]
            to_rank = int(move[3])

            if is_engine_notation:
                # Engine notation: rank 0-9 (0=red bottom, 9=black top)
                # Hi·ªÉn th·ªã nh∆∞ engine notation
                from_pos = f"{from_file}{from_rank}"
                to_pos = f"{to_file}{to_rank}"
            else:
                # Board notation: rank 0-9 (0=black top, 9=red bottom)
                # Chuy·ªÉn ƒë·ªïi sang engine notation ƒë·ªÉ hi·ªÉn th·ªã
                display_from_rank = 9 - from_rank
                display_to_rank = 9 - to_rank
                from_pos = f"{from_file}{display_from_rank}"
                to_pos = f"{to_file}{display_to_rank}"

            return f"{from_pos} ‚Üí {to_pos}"

        except (IndexError, ValueError):
            return move

    def convert_moves_to_engine_notation(self, board_moves):
        """
        Chuy·ªÉn ƒë·ªïi moves t·ª´ board notation sang engine notation

        Args:
            board_moves: List moves trong board notation

        Returns:
            list: Moves trong engine notation
        """
        engine_moves = []
        print(
            f"üîÑ Converting {len(board_moves)} board moves to engine notation")

        for i, move in enumerate(board_moves):
            if len(move) == 4:
                # Parse board move: e.g., "a9b8" (board notation)
                from_file = move[0]
                from_rank = int(move[1])
                to_file = move[2]
                to_rank = int(move[3])

                # Chuy·ªÉn ƒë·ªïi sang engine notation (ƒë·∫£o ng∆∞·ª£c rank)
                # Board rank 0-9 -> Engine rank 9-0
                engine_from_rank = 9 - from_rank
                engine_to_rank = 9 - to_rank

                # T·∫°o engine move notation
                engine_move = f"{from_file}{engine_from_rank}{to_file}{engine_to_rank}"
                engine_moves.append(engine_move)

                if i < 3 or i >= len(board_moves) - 3:  # Show first 3 and last 3
                    print(f"üìù Move {i+1}: {move} -> {engine_move}")

        print(f"‚úÖ Converted to {len(engine_moves)} engine moves")
        return engine_moves

    def get_hint(self):
        """Request hint from the engine"""
        if self.engine_manager.get_current_engine():
            # T·∫Øt analysis mode n·∫øu ƒëang b·∫≠t
            if hasattr(self, 'analysis_enabled') and self.analysis_enabled:
                self.analysis_enabled = False
                self.analyze_action.setChecked(False)
                # D·ª´ng engine analysis
                engine = self.engine_manager.get_current_engine()
                engine.stop_search()
                self.update_status("‚ö†Ô∏è ƒê√£ t·∫Øt ph√¢n t√≠ch ƒë·ªÉ th·ª±c hi·ªán g·ª£i √Ω")

                # ƒê·∫∑t flag ƒë·ªÉ ignore engine info c≈©
                self.ignore_engine_info = True
                # Delay ng·∫Øn ƒë·ªÉ engine d·ª´ng ho√†n to√†n tr∆∞·ªõc khi g·ª£i √Ω
                QTimer.singleShot(200, self._request_hint)
            else:
                # Kh√¥ng c√≥ analysis mode, g·ª£i √Ω ngay
                self._request_hint()
        else:
            self.update_status("‚ùå C·∫ßn load engine tr∆∞·ªõc khi g·ª£i √Ω")

    def _request_hint(self):
        """Th·ª±c hi·ªán request hint sau khi ƒë√£ d·ª´ng analysis"""
        if self.engine_manager.get_current_engine():
            # Reset flag ƒë·ªÉ nh·∫≠n engine info m·ªõi
            self.ignore_engine_info = False

            engine = self.engine_manager.get_current_engine()
            current_fen = self.game_state.to_fen()
            if current_fen:
                engine_moves = self.convert_moves_to_engine_notation(
                    self.game_state.move_history)
                engine.set_position(current_fen, engine_moves)
                engine.get_hint(depth=15)
                self.update_status("ü§ñ ƒêang y√™u c·∫ßu g·ª£i √Ω t·ª´ engine...")
            else:
                self.update_status("‚ùå Kh√¥ng c√≥ v·ªã tr√≠ ƒë·ªÉ g·ª£i √Ω")

    def start_new_analysis(self, engine, current_fen, engine_moves):
        """B·∫Øt ƒë·∫ßu analysis m·ªõi v·ªõi position hi·ªán t·∫°i"""
        if hasattr(self, 'analysis_enabled') and self.analysis_enabled:
            # Reset flag ƒë·ªÉ nh·∫≠n engine info m·ªõi
            self.ignore_engine_info = False
            # Set position m·ªõi
            engine.set_position(current_fen, engine_moves)
            # B·∫Øt ƒë·∫ßu analysis m·ªõi
            engine.go_infinite()
            print(f"üîç B·∫Øt ƒë·∫ßu analysis m·ªõi cho position: {current_fen}")

    def flip_board(self):
        """L·∫≠t b√†n c·ªù ƒë·ªÉ xem t·ª´ g√≥c nh√¨n ƒë·ªëi ph∆∞∆°ng"""
        # Toggle flip state c·ªßa board widget
        self.board_widget.flip_board()

        # C·∫≠p nh·∫≠t status
        if self.board_widget.is_flipped:
            self.update_status("üîÑ ƒê√£ l·∫≠t b√†n c·ªù - Xem t·ª´ g√≥c nh√¨n qu√¢n ƒêen")
        else:
            self.update_status("üîÑ ƒê√£ l·∫≠t b√†n c·ªù - Xem t·ª´ g√≥c nh√¨n qu√¢n ƒê·ªè")

    def toggle_coordinate_style(self):
        """Toggle gi·ªØa t·ªça ƒë·ªô qu·ªëc t·∫ø (a-i/0-9) v√† ki·ªÉu Trung Qu·ªëc (1-9)"""
        # Toggle coordinate style c·ªßa board widget
        self.board_widget.toggle_coordinate_style()

        # C·∫≠p nh·∫≠t status
        if self.board_widget.chinese_coords:
            self.update_status("üìç ƒê√£ chuy·ªÉn sang t·ªça ƒë·ªô ki·ªÉu Trung Qu·ªëc (1-9)")
        else:
            self.update_status("üìç ƒê√£ chuy·ªÉn sang t·ªça ƒë·ªô qu·ªëc t·∫ø (a-i/0-9)")

    def toggle_move_notation_style(self):
        """Toggle gi·ªØa k√Ω hi·ªáu n∆∞·ªõc ƒëi qu·ªëc t·∫ø v√† ki·ªÉu Trung Qu·ªëc"""
        self.chinese_move_notation = not self.chinese_move_notation

        # C·∫≠p nh·∫≠t status
        if self.chinese_move_notation:
            self.update_status("üìù ƒê√£ chuy·ªÉn sang k√Ω hi·ªáu n∆∞·ªõc ƒëi Trung Qu·ªëc")
        else:
            self.update_status("üìù ƒê√£ chuy·ªÉn sang k√Ω hi·ªáu n∆∞·ªõc ƒëi qu·ªëc t·∫ø")

        # Refresh game info ƒë·ªÉ hi·ªÉn th·ªã l·∫°i moves v·ªõi style m·ªõi
        self.refresh_move_history()

    def refresh_move_history(self):
        """Refresh l·∫°i history moves v·ªõi style notation m·ªõi"""
        if hasattr(self, 'game_info_widget'):
            # Clear current moves v√† rebuild
            self.game_info_widget.clear_moves()

            # Rebuild t·ª´ game state history
            for i, move in enumerate(self.game_state.move_history):
                formatted_move = self.format_move_for_display(move, i)
                self.game_info_widget.add_move(formatted_move)

    def format_move_for_display(self, move, move_index=None):
        """
        Format move cho hi·ªÉn th·ªã d·ª±a tr√™n style ƒë√£ ch·ªçn

        Args:
            move: Move notation (e.g., "e0e1")
            move_index: Index c·ªßa move trong history (ƒë·ªÉ x√°c ƒë·ªãnh qu√¢n c·ªù)

        Returns:
            str: Formatted move
        """
        if self.chinese_move_notation and move_index is not None:
            # Ki·ªÉu Trung Qu·ªëc: c·∫ßn th√¥ng tin v·ªÅ qu√¢n c·ªù ƒë√£ di chuy·ªÉn
            return self.format_move_chinese_from_history(move, move_index)
        else:
            # Ki·ªÉu qu·ªëc t·∫ø
            return self.format_move_notation(move, is_engine_notation=False)

    def format_move_chinese_from_history(self, move, move_index):
        """
        Format move theo ki·ªÉu Trung Qu·ªëc t·ª´ history
        """
        try:
            # Parse move notation
            if len(move) != 4:
                return move

            from_col = ord(move[0]) - ord('a')
            from_row = int(move[1])
            to_col = ord(move[2]) - ord('a')
            to_row = int(move[3])

            # X√°c ƒë·ªãnh qu√¢n c·ªù ƒë√£ di chuy·ªÉn t·ª´ history
            # C·∫ßn replay l·∫°i moves ƒë·ªÉ bi·∫øt qu√¢n g√¨ ƒë√£ di chuy·ªÉn
            piece = self.get_piece_from_move_history(
                move_index, from_row, from_col)
            if piece:
                # X√°c ƒë·ªãnh player t·ª´ move index
                current_player = 'red' if move_index % 2 == 0 else 'black'

                # S·ª≠ d·ª•ng function t·ª´ constants.py
                from ..utils.constants import format_move_chinese_style
                return format_move_chinese_style(piece, from_row, from_col, to_row, to_col, current_player)
            else:
                # Fallback v·ªÅ notation c≈©
                return self.format_move_notation(move, is_engine_notation=False)

        except Exception as e:
            print(f"L·ªói format move Chinese: {e}")
            return self.format_move_notation(move, is_engine_notation=False)

    def get_piece_from_move_history(self, move_index, from_row, from_col):
        """
        L·∫•y qu√¢n c·ªù ƒë√£ di chuy·ªÉn t·ª´ history b·∫±ng c√°ch replay moves
        """
        try:
            # T·∫°o temporary game state ƒë·ªÉ replay
            from ..core.game_state import GameState
            temp_game = GameState()

            # Replay t·∫•t c·∫£ moves cho ƒë·∫øn move_index
            for i in range(move_index + 1):
                if i < len(self.game_state.move_history):
                    move = self.game_state.move_history[i]
                    if len(move) == 4:
                        move_from_col = ord(move[0]) - ord('a')
                        move_from_row = int(move[1])
                        move_to_col = ord(move[2]) - ord('a')
                        move_to_row = int(move[3])

                        if i == move_index:
                            # ƒê√¢y l√† move ch√∫ng ta quan t√¢m
                            return temp_game.board[move_from_row][move_from_col]
                        else:
                            # Replay move n√†y
                            temp_game.make_move(
                                move_from_row, move_from_col, move_to_row, move_to_col)

            return None
        except Exception as e:
            print(f"L·ªói get piece from history: {e}")
            return None

    def on_multi_engine_hint_selected(self, engine_name: str, move: str):
        """X·ª≠ l√Ω khi user ch·ªçn hint t·ª´ multi-engine"""
        print(f"üéØ Ch·ªçn g·ª£i √Ω t·ª´ {engine_name}: {move}")

        # Highlight move tr√™n board
        if len(move) >= 4:
            from_pos = move[:2]
            to_pos = move[2:4]

            # Convert sang board coordinates
            from_coords = self.board_widget._pos_to_coords(from_pos)
            to_coords = self.board_widget._pos_to_coords(to_pos)

            if from_coords and to_coords:
                from_row, from_col = from_coords
                to_row, to_col = to_coords

                # Set engine hint ƒë·ªÉ highlight
                self.board_widget.set_engine_hint(
                    (from_row, from_col, to_row, to_col))

                self.update_status(f"ü§ñ G·ª£i √Ω t·ª´ {engine_name}: {move}")

    def on_multi_engine_arrows_changed(self, arrows_data: dict):
        """X·ª≠ l√Ω khi multi-engine arrows thay ƒë·ªïi"""
        # Update board widget v·ªõi arrows m·ªõi
        self.board_widget.set_multi_engine_arrows(arrows_data)
